# RISC-V Learning Notes

## 1 efl文件

RISC-V是一个开放的指令集架构，与其他架构不同，RISC-V的架构不受任何专利或其他限制。RISC-V提供了许多标准化的文件格式，其中之一就是EFL（Executable and Linkable Format），它类似于其他系统中的ELF文件格式。下面是RISC-V64 EFL文件的各个组成部分：

1. ELF头部（ELF Header）：包含文件类型、目标架构、程序头部表偏移量、程序头部表项数量等基本信息，指定了文件的类型和结构。
2. 程序头部表（Program Header Table）：描述了文件中各个段的信息。每个段描述了一个区域，例如.text段是存放代码的区域，.data段是存放数据的区域等等。
3. 代码段（Text Segment）：这个段包含了可执行的指令，是程序的主要部分。
4. 数据段（Data Segment）：这个段包含了全局变量、静态变量等数据。
5. 符号表（Symbol Table）：存放了代码中定义的所有符号的信息，包括符号名称、类型、值等。
6. 字符串表（String Table）：包含了符号表中使用的所有字符串，例如符号名称、段名称等。
7. 重定位表（Relocation Table）：由编译器在编译时生成，存储了所有需要在程序加载时进行重定位的地址信息。

总的来说，RISC-V64 EFL文件包含了程序的所有代码、数据、符号和重定位信息等。操作系统在加载EFL文件时，将会根据ELF头部中的信息读取各个段，并进行重定位，最终生成可执行的程序。

## 2 RISCV 指令

### 2.1 slli

RISC-V汇编语言中的slli指令是一个逻辑左移指令，用于将一个寄存器中的值逻辑左移一定的位数，并将结果存储回同一个寄存器中。

slli指令的语法如下：

```asm
slli rd, rs1, shamt
```

其中，rd是目的寄存器，rs1是源寄存器，shamt是移位数量，必须是一个在0到31之间的整数。指令将rs1的值逻辑左移shamt位，并将结果存储回rd寄存器中。

例如，以下指令将寄存器x1的值逻辑左移3位，并将结果存储回寄存器x2中：

```asm
slli x2, x1, 3
```

如果寄存器x1包含二进制数01010101，则slli指令的结果为10101000，因为01010101逻辑左移3位后变为10101000。

### 2.2 la

RISC-V汇编语言中的la指令是一个加载地址指令，用于将某个标签的地址加载到指定寄存器中。

la指令的语法如下：

```asm
la rd, label
```

其中，rd是目的寄存器，label是要加载地址的标签名。指令将label的地址加载到rd寄存器中。

例如，以下指令将标签my_data的地址加载到寄存器x1中：

```asm
la x1, my_data
```

在汇编代码中定义一个标签，可以使用以下语法：

```asm
my_data:
    .word 0x12345678
```

标签my_data定义了一个32位的数据单元，并初始化为0x12345678。在运行la指令之前，编译器会为my_data生成一个地址，并将该地址嵌入到la指令中。

因此，执行la x1, my_data指令后，寄存器x1将包含my_data的地址。在访问my_data时，可以使用la指令加载其地址，并使用lw或sw指令读取或写入其中的数据。

### 2.3 wfi

RISC-V汇编语言中的wfi指令（wait for interrupt）是一个等待中断指令，用于让CPU进入低功耗状态，等待中断事件的发生。当CPU执行wfi指令时，它会停止执行，进入等待状态，直到收到中断信号时才会被唤醒并继续执行后续指令。

wfi指令的语法如下：

```asm
wfi
```

wfi指令执行时，CPU会进入低功耗模式，并等待中断信号的到来。在等待中断时，CPU不会执行任何指令，也不会消耗系统资源，以节省功耗。一旦中断信号到来，CPU会被唤醒，继续执行后续指令。

在操作系统内核的实现中，wfi指令通常用于让CPU进入低功耗状态，以降低系统功耗和热量，延长电池寿命。此外，wfi指令还可以用于实现空闲等待状态，让CPU等待其他处理器或外设的操作完成，以降低CPU的占用率，提高系统资源利用率。

### 2.4 .skip

`.skip`指令是RISC-V汇编语言中用于分配内存空间的伪指令（pseudo-instruction），其语法如下：

```asm
.skip size
```

它的作用是在当前位置分配指定大小的空间，它并不真正地生成任何指令，而是将指令转换为等效的汇编代码。

例如，`.skip 16`会分配16个字节的空间，并将程序计数器（PC）增加16。在汇编代码中，`.skip`指令会被转换为多个`.zero`指令，这些指令将分配的空间全部初始化为0。

`.skip`指令通常用于在程序中预留空间，用于存储数据或其他代码。它可以与`.word`指令一起使用，来为数据分配空间，例如：

```asm
my_data:
    .word 1, 2, 3, 4, 5
    .skip 16
```

在上面的示例中，`.word`指令分配了一个包含5个32位整数的数据区域，`.skip`指令分配了16字节的空间，用于存储其他数据。

需要注意的是，由于`.skip`指令只是一个伪指令，不是RISC-V指令集的一部分，因此不是所有的汇编器都支持它。一些汇编器可能会使用不同的伪指令来实现相同的功能。

**example:**

```asm
stacks:
	.skip	STACK_SIZE * MAXNUM_CPU # allocate space for all the harts stacks

	.end				# End of file
```

这段代码使用了RISC-V汇编语言中的`.skip`指令来分配内存空间，并为每个CPU核心分配了一个固定大小的栈空间。

`.skip`指令的语法如下：

```asm
.skip	size
```

它的作用是为指定的字节数分配内存空间，并返回一个指向该内存空间起始地址的符号。在这个代码片段中，`.skip`指令的参数为`STACK_SIZE * MAXNUM_CPU`，也就是为每个CPU核心分配了`STACK_SIZE`大小的栈空间，总共分配了`MAXNUM_CPU`个栈空间的内存。这里的`STACK_SIZE`是指栈的大小，`MAXNUM_CPU`是指CPU核心的数量。

在这个代码片段中，`.skip`指令返回的符号是`stacks`，这个符号表示分配的内存空间的起始地址。

此外，该代码片段还使用了`.end`指令，表示文件的结束。`.end`指令没有任何参数，它的作用是告诉编译器已经到达了文件的结尾。

综上所述，这段代码的作用是为每个CPU核心分配固定大小的栈空间，以便进行函数调用和局部变量存储。`stacks`符号表示分配的内存空间的起始地址。

### 2.5 .equ

`.equ`指令是RISC-V汇编语言中用于定义符号常量的伪指令（pseudo-instruction），其语法如下：

```asm
.equ symbol, expression
```

它的作用是将一个符号常量与一个表达式进行关联，使得在汇编代码中可以使用该符号常量来代替表达式。当汇编器在处理代码时遇到该符号常量，就会将其替换为与之关联的表达式。

例如，`.equ STACK_SIZE, 1024`会定义一个名为`STACK_SIZE`的符号常量，并将其关联到值为1024的表达式。在汇编代码中，可以使用`STACK_SIZE`符号常量来代替`1024`，例如：

```asm
la sp, stacks + STACK_SIZE
```

在上面的示例中，`STACK_SIZE`符号常量被用于计算`stacks`标号加上一个栈大小的偏移量，以获取栈的顶部地址。

需要注意的是，由于`.equ`指令只是一个伪指令，不是RISC-V指令集的一部分，因此不是所有的汇编器都支持它。一些汇编器可能会使用不同的伪指令来实现相同的功能。

### 2.6 start_kernel()

`start_kernel()` 是 Linux 内核启动过程中的一个非常重要的函数。在 RISC-V 架构下，`start_kernel()` 函数的定义在 `arch/riscv/kernel/head.S` 文件中。当开机时，CPU 会从一个预定义的地址开始执行代码，这个地址指向了操作系统内核的入口函数，而在 RISC-V 架构下，这个入口函数就是 `start_kernel()`。

`start_kernel()` 函数主要完成以下工作：

1. 初始化 CPU 和硬件设备，包括设置 CPU 时钟、初始化中断控制器、开启内存映射等。
2. 进行内存管理的初始化，包括建立物理内存映射表、初始化虚拟内存管理等。
3. 初始化进程和线程管理，包括创建内核线程、初始化进程调度等。
4. 初始化文件系统和网络子系统，包括加载文件系统、初始化网络协议栈等。
5. 执行启动用户空间的一系列操作，包括初始化 `init` 进程、执行用户空间初始化脚本等。

一旦 `start_kernel()` 函数执行完毕，操作系统内核就正式启动了。在 `start_kernel()` 函数执行之后，会进入到一个死循环中，等待处理中断和调度进程。